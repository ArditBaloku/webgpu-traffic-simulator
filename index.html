<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="osm-read-pbf.js"></script>
    <script src="osm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="mappa.js"></script>
    <script src="cpu.js"></script>
    <script src="gpu.js"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div style="display: flex; justify-content: start">
      <div id="left"></div>
      <!-- make a straight line to divide these two divs vertically -->
      <div style="border-left: 5px solid black; height: 700px"></div>
      <div id="right"></div>
    </div>
    <script>
      let ready = false;
      let cpuCars = [];
      let gpuCars = [];
      const mappa = new Mappa('Leaflet');
      const options = {
        lat: 42.65221,
        lng: 21.17623,
        zoom: 17,
        style: 'http://{s}.tile.osm.org/{z}/{x}/{y}.png',
      };

      const s = (sketch) => {
        let myMap;

        sketch.setup = () => {
          const canvas = sketch.createCanvas(700, 700);
          myMap = mappa.tileMap(options);
          myMap.overlay(canvas);
        };

        sketch.draw = () => {
          if (!ready) {
            return;
          }

          sketch.clear();

          drawWays(sketch);
          drawCells(sketch);
          drawCars(sketch);
          drawStatistics(sketch);
        };

        function drawWays(sketch) {
          ways.forEach((way) => {
            for (let i = 0; i < way.nodes.length - 1; i++) {
              const node1 = way.nodes[i];
              const node2 = way.nodes[i + 1];

              const node1PixelCoords = myMap.latLngToPixel(node1.lat, node1.lon);
              const node2PixelCoords = myMap.latLngToPixel(node2.lat, node2.lon);

              sketch.line(
                node1PixelCoords.x,
                node1PixelCoords.y,
                node2PixelCoords.x,
                node2PixelCoords.y
              );
            }
          });
        }

        function drawCells(sketch) {
          sketch.fill(255, 255, 255);

          ways.forEach((way) => {
            way.nodes.forEach((node) => {
              const nodePixelCoords = myMap.latLngToPixel(node.lat, node.lon);
              sketch.rect(nodePixelCoords.x, nodePixelCoords.y, 4, 4);
            });
          });
        }

        function drawCars(sketch) {
          if (!sketch.cars) {
            return;
          }

          sketch.fill(0, 0, 0);

          sketch.cars.forEach((car) => {
            drawCar(car, sketch);
          });
        }

        function drawCar(car, sketch) {
          if (car.speed == 0) {
            sketch.fill(0, 0, 0);
          } else if (car.speed == 1) {
            sketch.fill(255, 255, 0);
          } else if (car.speed == 2) {
            sketch.fill(0, 255, 0);
          }
          const carPixelCoords = myMap.latLngToPixel(car.lat, car.lon);
          sketch.rect(carPixelCoords.x, carPixelCoords.y, 12, 8);

          sketch.fill(255, 0, 0);
          sketch.textSize(12);
          sketch.text(car.id, carPixelCoords.x + 2, carPixelCoords.y + 2);
        }

        function drawStatistics(sketch) {
          sketch.textSize(24);
          sketch.fill(0, 0, 0);
          sketch.text(`Step: ${step}`, 50, 40);

          let areSimulationsSynced = true;
          if (cpuCars.length !== gpuCars.length) {
            areSimulationsSynced = false;
          } else {
            cpuCars.sort((a, b) => a.id - b.id);
            gpuCars.sort((a, b) => a.id - b.id);

            for (let i = 0; i < cpuCars.length; i++) {
              if (
                cpuCars[i].id !== gpuCars[i].id ||
                cpuCars[i].nodeId.toString() !== gpuCars[i].nodeId.toString() ||
                cpuCars[i].wayId.toString() !== gpuCars[i].wayId.toString() ||
                cpuCars[i].speed !== gpuCars[i].speed
              ) {
                areSimulationsSynced = false;
                break;
              }
            }
          }

          sketch.textSize(24);
          sketch.text('Sync status: ', 50, 80);

          if (areSimulationsSynced) {
            sketch.fill(0, 255, 0);
          } else {
            sketch.fill(255, 0, 0);
          }

          sketch.text(areSimulationsSynced ? 'Synced' : 'Not synced', 180, 80);
        }
      };

      let leftP5 = new p5(s, 'left');
      let rightP5 = new p5(s, 'right');

      let step = 0;
      const interval = setInterval(() => {
        computePassCpu();
        computePassGpu().then(() => {
          leftP5.cars = cpuCars;
          rightP5.cars = gpuCars;
        });

        step++;
      }, 1000);
    </script>
  </body>
</html>
